<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Pymultikdf by sundarnagarajan</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Pymultikdf</h1>
      <h2 class="project-tagline">Python wrappers for bcrypt, PBKDF2 (fastpbkdf2) scrypt (Tarsnap)</h2>
      <a href="https://github.com/sundarnagarajan/pymultikdf" class="btn">View on GitHub</a>
      <a href="https://github.com/sundarnagarajan/pymultikdf/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/sundarnagarajan/pymultikdf/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="pymultikdf" class="anchor" href="#pymultikdf" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>pymultikdf</h1>

<p>This python module provides wrappers for C functions implementing the
following Key Derivation Functions (KDF)s:</p>

<ul>
<li>PBKDF2</li>
<li>bcrypt</li>
<li>scrypt</li>
</ul>

<h2>
<a id="what-is-a-key-derivation-function" class="anchor" href="#what-is-a-key-derivation-function" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>What is a Key Derivation Function?</h2>

<p>From wikipedia (<a href="https://en.wikipedia.org/wiki/Key_derivation_function">https://en.wikipedia.org/wiki/Key_derivation_function</a>):</p>

<p>In cryptography, a key derivation function (or KDF) derives one or more secret keys from a secret value such as a master key, a password, or a passphrase using a pseudo-random function.[1][2] KDFs can be used to stretch keys into longer keys or to obtain keys of a required format, such as converting a group element that is the result of a Diffie–Hellman key exchange into a symmetric key for use with AES. Keyed cryptographic hash functions are popular examples of pseudo-random functions used for key derivation.</p>

<h3>
<a id="what-is-pbkdf2" class="anchor" href="#what-is-pbkdf2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>What is PBKDF2?</h3>

<p>PBKDF2 (Password-Based Key Derivation Function 2) is a key derivation function that is part of RSA Laboratories' Public-Key Cryptography Standards (PKCS) series, specifically PKCS #5 v2.0, also published as Internet Engineering Task Force's RFC 2898. It replaces an earlier standard, PBKDF1, which could only produce derived keys up to 160 bits long.</p>

<p>See: <a href="https://en.wikipedia.org/wiki/PBKDF2">https://en.wikipedia.org/wiki/PBKDF2</a></p>

<h3>
<a id="what-is-bcrypt" class="anchor" href="#what-is-bcrypt" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>What is bcrypt?</h3>

<p>bcrypt is a key derivation function for passwords designed by Niels Provos and David Mazières, based on the Blowfish cipher, and presented at USENIX in 1999.[1] Besides incorporating a salt to protect against rainbow table attacks, bcrypt is an adaptive function: over time, the iteration count can be increased to make it slower, so it remains resistant to brute-force search attacks even with increasing computation power.</p>

<p>The bcrypt function is the default password hash algorithm for BSD and other systems including some Linux distributions such as SUSE Linux.[2] The prefix "$2a$" or "$2b$" (or "$2y$") in a hash string in a shadow password file indicates that hash string is a bcrypt hash in modular crypt format.[3] The rest of the hash string includes the cost parameter, a 128-bit salt (base-64 encoded as 22 characters), and 184 bits of the resulting hash value (base-64 encoded as 31 characters).[4] The cost parameter specifies a key expansion iteration count as a power of two, which is an input to the crypt algorithm.</p>

<p>See: <a href="https://en.wikipedia.org/wiki/Bcrypt">https://en.wikipedia.org/wiki/Bcrypt</a></p>

<h3>
<a id="what-is-scrypt" class="anchor" href="#what-is-scrypt" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>What is scrypt?</h3>

<p>In cryptography, scrypt is a password-based key derivation function created by Colin Percival, originally for the Tarsnap online backup service.[1] The algorithm was specifically designed to make it costly to perform large-scale custom hardware attacks by requiring large amounts of memory. In 2012, the scrypt algorithm was published by IETF as an Internet Draft, intended to become an informational RFC.[2]</p>

<p>See: <a href="https://en.wikipedia.org/wiki/Scrypt">https://en.wikipedia.org/wiki/Scrypt</a></p>

<h1>
<a id="relationship-to-existing-packages" class="anchor" href="#relationship-to-existing-packages" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Relationship to existing packages</h1>

<p>Existing python packages for PBKDF2, bcrypt, scrypt</p>

<ul>
<li>pip install fastpbkdf2</li>
<li>pip install bcrypt</li>
<li>pip install scrypt</li>
</ul>

<h2>
<a id="why-a-new-module" class="anchor" href="#why-a-new-module" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Why a new module?</h2>

<p>Sometimes one wants to try or use MULTIPLE different Key Derivation Functions.  In such cases, instead of installing MULTIPLE SEPARATE python, packages, just this single module can be installed and used.</p>

<p>This may also be a convenience when porting your code to run under 'Python For Android (<a href="https://github.com/kivy/python-for-android">https://github.com/kivy/python-for-android</a>)</p>

<h2>
<a id="are-there-any-differences" class="anchor" href="#are-there-any-differences" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Are there any differences?</h2>

<p>Exactly and ONLY the following C functions have been wrapped</p>

<p>From fastpbkdf2:</p>

<pre><code>fastpbkdf2_hmac_sha1
fastpbkdf2_hmac_sha256
fastpbkdf2_hmac_sha512
</code></pre>

<p>From bcrypt:</p>

<pre><code>bcrypt_kdf
</code></pre>

<p>From scrypt:</p>

<pre><code>crypto_scrypt
</code></pre>

<p>The following methods should be exactly equivalent to the corresponding methods in the existing python wrappers:</p>

<pre><code>    ---------------------------------------------------------------
    Module.method                       Identical to
    ---------------------------------------------------------------
    multikdf.fastpbkdf2.pbkdf2_hmac     fastpbkdf2.pbkdf2_hmac
    multikdf.bcrypt.kdf                 bcrypt.kdf
    multikdf.scrypt.hash                scrypt.hash
    ---------------------------------------------------------------
</code></pre>

<h1>
<a id="test-code" class="anchor" href="#test-code" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Test code</h1>

<p>See multikdf.test (test.py under the multikdf module directory)</p>

<pre lang="sourceCode"><code>    import os
    from .fastpbkdf2 import pbkdf2, algorithm as hash_algorithms
    from .bcrypt import bcrypt_kdf
    from .scrypt import scrypt_kdf

    min_passwd_len = 8
    max_passwd_len = 10

    min_pbkdf_rounds = 1000
    max_pbkdf_rounds = 5000
    step_pbkdf_rounds = 200

    min_bcrypt_rounds = 2
    max_bcrypt_rounds = 8

    min_scrypt_r = 7
    max_scrypt_r = 8
    min_scrypt_p = 1
    max_scrypt_p = 2
    min_scrypt_n = 13
    max_scrypt_n = 14

    def test_pbkdf2(s):
        for l in range(min_passwd_len, max_passwd_len + 1):
            i = os.urandom(l)
            for r in range(min_pbkdf_rounds,
                           max_pbkdf_rounds + 1,
                           step_pbkdf_rounds):
                for h in hash_algorithms.keys():
                    print('Testing pbkdf2: l=%d, r=%d, h=%s' % (l, r, h))
                    pbkdf2(i, s, r=r, kl=kl, h=h)

    def test_bcrypt(s):
        for l in range(min_passwd_len, max_passwd_len + 1):
            i = os.urandom(l)
            for r in range(min_bcrypt_rounds, max_bcrypt_rounds + 1):
                print('Testing bcrypt: l=%d, r=%d' % (l, r))
                bcrypt_kdf(i, s, r=r, kl=kl)

    def test_scrypt(s):
        for l in range(min_passwd_len, max_passwd_len + 1):
            i = os.urandom(l)
            for r in range(min_scrypt_r, max_scrypt_r + 1):
                for p in range(min_scrypt_p, max_scrypt_p + 1):
                    for n in range(min_scrypt_n, max_scrypt_n + 1):
                        print('Testing scrypt: l=%d, r=%d, p=%d, n=%d' % (
                            l, r, p, n))
                        scrypt_kdf(i, s, r=r, p=p, n=n, kl=kl)

    s = os.urandom(64)
    kl = 64

    test_pbkdf2(s)
    test_bcrypt(s)
    test_scrypt(s)
</code></pre>

<h1>
<a id="installing" class="anchor" href="#installing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>INSTALLING:</h1>

<p>From github directly using pip:</p>

<pre><code>pip install 'git+https://github.com/sundarnagarajan/pymultikdf.git'
</code></pre>

<p>From github after downloading / cloning:</p>

<pre><code>python setup.py install
</code></pre>

<p>From pypi:</p>

<pre><code>pip install multikdf
</code></pre>

<h1>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>LICENSE</h1>

<p>The files under multikdf/c/fastpbkdf2 are from ctz and are copied unchanged from <a href="https://github.com/ctz/fastpbkdf2.git">https://github.com/ctz/fastpbkdf2.git</a> These files under the terms of the CC0 1.0 Universal License - see the file named LICENSE under multikdf/c/fastpbkdf2</p>

<p>The files under multikdf/c/py-bcrypt are from py-bcrypt (automatically exported from code.google.com/p/py-bcrypt) and imported unchanged.  These files under the terms of the ISC/BSD licence. See the file named LICENSE under multikdf/c/py-bcrypt</p>

<p>The files under multikdf/c/scrypt are from Tarsnap and are copied unchanged from <a href="https://github.com/Tarsnap/scrypt.git">https://github.com/Tarsnap/scrypt.git</a> The files under multikdf/c/scrypt/lib are licensed under the terms of the 2-clause BSD license. See the file named README.md under the directory multikdf/c/scrypt/lib.</p>

<p>The files under multikdf/c/scrypt/libcperciva are licensed under the terms of the license specified in the file multikdf/c/scrypt/libcperciva/COPYRIGHT.  </p>

<p>All remaining files in this package are licensed under the GNU General Public License version 3 or (at your option) any later version.  See the file LICENSE-GPLv3.txt for details of the GNU General Public License version 3.</p>

<h1>
<a id="documentation-pydoc" class="anchor" href="#documentation-pydoc" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Documentation (pydoc)</h1>

<h2>
<a id="package-multikdf" class="anchor" href="#package-multikdf" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Package multikdf</h2>

<h3>
<a id="package-contents" class="anchor" href="#package-contents" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>PACKAGE CONTENTS</h3>

<pre><code>bcrypt
fastpbkdf2
libmultikdf
scrypt
test
</code></pre>

<h3>
<a id="functions" class="anchor" href="#functions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>FUNCTIONS</h3>

<pre><code>getbuf(l)
</code></pre>

<h2>
<a id="multikdffastpbkdf2" class="anchor" href="#multikdffastpbkdf2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>multikdf.fastpbkdf2</h2>

<h3>
<a id="functions-1" class="anchor" href="#functions-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>FUNCTIONS</h3>

<pre><code>pbkdf2(i, s, r=1000, kl=64, h='SHA512')
    i--&gt;bytes: input data (password etc)
    s--&gt;bytes: salt
    r--&gt;int: rounds
    kl--&gt;int: desired key length in bytes
    h--&gt;str: hash function (name)

    Returns--&gt;bytes:

pbkdf2_hmac(h, i, s, r, kl=None)
    Should be identical to original fastpbkdf2.pbkdf2_hmac
    h--&gt;str: hash function (name)
    i--&gt;bytes: input data (password etc)
    s--&gt;bytes: salt
    r--&gt;int: rounds
    kl--&gt;int: desired key length in bytes

    Returns--&gt;bytes:
</code></pre>

<h3>
<a id="data" class="anchor" href="#data" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DATA</h3>

<pre><code>algorithm = {'sha1': None, 'sha256': None, 'sha512': None}
</code></pre>

<h2>
<a id="multikdfbcrypt" class="anchor" href="#multikdfbcrypt" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>multikdf.bcrypt</h2>

<h3>
<a id="functions-2" class="anchor" href="#functions-2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>FUNCTIONS</h3>

<pre><code>bcrypt_kdf(i, s, r=10, kl=64)
    i--&gt;bytes: input data (password etc)
    s--&gt;bytes: salt (os.urandom)
    r--&gt;int: rounds
    kl--&gt;int: desired key length in bytes
    Returns--&gt;bytes:

    (rounds * PerSec) = Machine-specific constant

kdf(password, salt, desired_key_bytes, rounds)
    Should be identical to original bcrypt.kdf
    password--&gt;bytes: input data (password etc)
    salt--&gt;bytes: salt
    desired_key_bytes--&gt;int: desired key length in bytes
    rounds--&gt;int: rounds

    Returns--&gt;bytes:
</code></pre>

<h2>
<a id="multikdfscrypt" class="anchor" href="#multikdfscrypt" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>multikdf.scrypt</h2>

<h3>
<a id="functions-3" class="anchor" href="#functions-3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>FUNCTIONS</h3>

<pre><code>hash(i, s, N=16384, r=8, p=1, buflen=64)
    Should be identical to scrypt.hash
    i--&gt;bytes: input data (password etc)
    s--&gt;bytes: salt
    N--&gt;int: General work factor. Should be a power of 2
             if N &lt; 2, it is set to 2. Defaults to 16384
    r--&gt;int: Memory cost - defaults to 8
    p--&gt;int: Compuation (parallelization) cost - defaults to 1
    buflen--&gt;int: Desired key length in bytes
    Returns--&gt;bytes:

scrypt_kdf(i, s, r=8, p=1, n=14, kl=64)
    i--&gt;bytes: input data (password etc)
    s--&gt;bytes: salt (os.urandom)
    r--&gt;int: Memory cost - defaults to 8
    p--&gt;int: Compuation (parallelization) cost - defaults to 1
    n--&gt;int: General work factor. passed to scrypt as 2^n
             if n &lt; 1, it is set to 1. Defaults to 14 (scrypt n=16384)
    Returns--&gt;bytes:

    (r * p) should be &lt; 2^30
    see pydoc scrypt.hash

    (2^n) * r * p * PerSec = Machine-specific constant
</code></pre>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/sundarnagarajan/pymultikdf">Pymultikdf</a> is maintained by <a href="https://github.com/sundarnagarajan">sundarnagarajan</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

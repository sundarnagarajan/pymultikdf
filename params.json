{
  "name": "Pymultikdf",
  "tagline": "Python wrappers for bcrypt, PBKDF2 (fastpbkdf2) scrypt (Tarsnap)",
  "body": "# pymultikdf\r\nThis python module provides wrappers for C functions implementing the\r\nfollowing Key Derivation Functions (KDF)s:\r\n  - PBKDF2\r\n  - bcrypt\r\n  - scrypt\r\n\r\n## What is a Key Derivation Function?\r\nFrom wikipedia (https://en.wikipedia.org/wiki/Key_derivation_function):\r\n\r\nIn cryptography, a key derivation function (or KDF) derives one or more secret keys from a secret value such as a master key, a password, or a passphrase using a pseudo-random function.[1][2] KDFs can be used to stretch keys into longer keys or to obtain keys of a required format, such as converting a group element that is the result of a Diffie–Hellman key exchange into a symmetric key for use with AES. Keyed cryptographic hash functions are popular examples of pseudo-random functions used for key derivation.\r\n\r\n### What is PBKDF2?\r\nPBKDF2 (Password-Based Key Derivation Function 2) is a key derivation function that is part of RSA Laboratories' Public-Key Cryptography Standards (PKCS) series, specifically PKCS #5 v2.0, also published as Internet Engineering Task Force's RFC 2898. It replaces an earlier standard, PBKDF1, which could only produce derived keys up to 160 bits long.\r\n\r\nSee: https://en.wikipedia.org/wiki/PBKDF2\r\n\r\n### What is bcrypt?\r\nbcrypt is a key derivation function for passwords designed by Niels Provos and David Mazières, based on the Blowfish cipher, and presented at USENIX in 1999.[1] Besides incorporating a salt to protect against rainbow table attacks, bcrypt is an adaptive function: over time, the iteration count can be increased to make it slower, so it remains resistant to brute-force search attacks even with increasing computation power.\r\n\r\nThe bcrypt function is the default password hash algorithm for BSD and other systems including some Linux distributions such as SUSE Linux.[2] The prefix \"$2a$\" or \"$2b$\" (or \"$2y$\") in a hash string in a shadow password file indicates that hash string is a bcrypt hash in modular crypt format.[3] The rest of the hash string includes the cost parameter, a 128-bit salt (base-64 encoded as 22 characters), and 184 bits of the resulting hash value (base-64 encoded as 31 characters).[4] The cost parameter specifies a key expansion iteration count as a power of two, which is an input to the crypt algorithm.\r\n\r\nSee: https://en.wikipedia.org/wiki/Bcrypt\r\n\r\n### What is scrypt?\r\nIn cryptography, scrypt is a password-based key derivation function created by Colin Percival, originally for the Tarsnap online backup service.[1] The algorithm was specifically designed to make it costly to perform large-scale custom hardware attacks by requiring large amounts of memory. In 2012, the scrypt algorithm was published by IETF as an Internet Draft, intended to become an informational RFC.[2]\r\n\r\nSee: https://en.wikipedia.org/wiki/Scrypt\r\n\r\n# Relationship to existing packages\r\nExisting python packages for PBKDF2, bcrypt, scrypt\r\n  - pip install fastpbkdf2\r\n  - pip install bcrypt\r\n  - pip install scrypt\r\n\r\n## Why a new module?\r\nSometimes one wants to try or use MULTIPLE different Key Derivation Functions.  In such cases, instead of installing MULTIPLE SEPARATE python, packages, just this single module can be installed and used.\r\n\r\nThis may also be a convenience when porting your code to run under 'Python For Android (https://github.com/kivy/python-for-android)\r\n\r\n## Are there any differences?\r\nExactly and ONLY the following C functions have been wrapped\r\n\r\nFrom fastpbkdf2:\r\n\r\n    fastpbkdf2_hmac_sha1\r\n    fastpbkdf2_hmac_sha256\r\n    fastpbkdf2_hmac_sha512\r\n\r\nFrom bcrypt:\r\n\r\n    bcrypt_kdf\r\n\r\nFrom scrypt:\r\n\r\n    crypto_scrypt\r\n\r\nThe following methods should be exactly equivalent to the corresponding methods in the existing python wrappers:\r\n\r\n        ---------------------------------------------------------------\r\n        Module.method                       Identical to\r\n        ---------------------------------------------------------------\r\n        multikdf.fastpbkdf2.pbkdf2_hmac     fastpbkdf2.pbkdf2_hmac\r\n        multikdf.bcrypt.kdf                 bcrypt.kdf\r\n        multikdf.scrypt.hash                scrypt.hash\r\n        ---------------------------------------------------------------\r\n\r\n# Test code\r\n  See multikdf.test (test.py under the multikdf module directory)\r\n\r\n~~~~ {.sourceCode .python}\r\n    import os\r\n    from .fastpbkdf2 import pbkdf2, algorithm as hash_algorithms\r\n    from .bcrypt import bcrypt_kdf\r\n    from .scrypt import scrypt_kdf\r\n\r\n    min_passwd_len = 8\r\n    max_passwd_len = 10\r\n\r\n    min_pbkdf_rounds = 1000\r\n    max_pbkdf_rounds = 5000\r\n    step_pbkdf_rounds = 200\r\n\r\n    min_bcrypt_rounds = 2\r\n    max_bcrypt_rounds = 8\r\n\r\n    min_scrypt_r = 7\r\n    max_scrypt_r = 8\r\n    min_scrypt_p = 1\r\n    max_scrypt_p = 2\r\n    min_scrypt_n = 13\r\n    max_scrypt_n = 14\r\n\r\n    def test_pbkdf2(s):\r\n        for l in range(min_passwd_len, max_passwd_len + 1):\r\n            i = os.urandom(l)\r\n            for r in range(min_pbkdf_rounds,\r\n                           max_pbkdf_rounds + 1,\r\n                           step_pbkdf_rounds):\r\n                for h in hash_algorithms.keys():\r\n                    print('Testing pbkdf2: l=%d, r=%d, h=%s' % (l, r, h))\r\n                    pbkdf2(i, s, r=r, kl=kl, h=h)\r\n\r\n    def test_bcrypt(s):\r\n        for l in range(min_passwd_len, max_passwd_len + 1):\r\n            i = os.urandom(l)\r\n            for r in range(min_bcrypt_rounds, max_bcrypt_rounds + 1):\r\n                print('Testing bcrypt: l=%d, r=%d' % (l, r))\r\n                bcrypt_kdf(i, s, r=r, kl=kl)\r\n\r\n    def test_scrypt(s):\r\n        for l in range(min_passwd_len, max_passwd_len + 1):\r\n            i = os.urandom(l)\r\n            for r in range(min_scrypt_r, max_scrypt_r + 1):\r\n                for p in range(min_scrypt_p, max_scrypt_p + 1):\r\n                    for n in range(min_scrypt_n, max_scrypt_n + 1):\r\n                        print('Testing scrypt: l=%d, r=%d, p=%d, n=%d' % (\r\n                            l, r, p, n))\r\n                        scrypt_kdf(i, s, r=r, p=p, n=n, kl=kl)\r\n\r\n    s = os.urandom(64)\r\n    kl = 64\r\n\r\n    test_pbkdf2(s)\r\n    test_bcrypt(s)\r\n    test_scrypt(s)\r\n~~~~\r\n\r\n\r\n# INSTALLING:\r\n  From github directly using pip:\r\n\r\n    pip install 'git+https://github.com/sundarnagarajan/pymultikdf.git'\r\n\r\n  From github after downloading / cloning:\r\n\r\n    python setup.py install\r\n\r\n  From pypi:\r\n\r\n    pip install multikdf\r\n\r\n# LICENSE\r\nThe files under multikdf/c/fastpbkdf2 are from ctz and are copied unchanged from https://github.com/ctz/fastpbkdf2.git These files under the terms of the CC0 1.0 Universal License - see the file named LICENSE under multikdf/c/fastpbkdf2\r\n\r\nThe files under multikdf/c/py-bcrypt are from py-bcrypt (automatically exported from code.google.com/p/py-bcrypt) and imported unchanged.  These files under the terms of the ISC/BSD licence. See the file named LICENSE under multikdf/c/py-bcrypt\r\n\r\nThe files under multikdf/c/scrypt are from Tarsnap and are copied unchanged from https://github.com/Tarsnap/scrypt.git The files under multikdf/c/scrypt/lib are licensed under the terms of the 2-clause BSD license. See the file named README.md under the directory multikdf/c/scrypt/lib.\r\n\r\nThe files under multikdf/c/scrypt/libcperciva are licensed under the terms of the license specified in the file multikdf/c/scrypt/libcperciva/COPYRIGHT.  \r\n\r\nAll remaining files in this package are licensed under the GNU General Public License version 3 or (at your option) any later version.  See the file LICENSE-GPLv3.txt for details of the GNU General Public License version 3.\r\n\r\n\r\n\r\n# Documentation (pydoc)\r\n\r\n## Package multikdf\r\n### PACKAGE CONTENTS\r\n    bcrypt\r\n    fastpbkdf2\r\n    libmultikdf\r\n    scrypt\r\n    test\r\n\r\n### FUNCTIONS\r\n    getbuf(l)\r\n\r\n## multikdf.fastpbkdf2\r\n\r\n### FUNCTIONS\r\n    pbkdf2(i, s, r=1000, kl=64, h='SHA512')\r\n        i-->bytes: input data (password etc)\r\n        s-->bytes: salt\r\n        r-->int: rounds\r\n        kl-->int: desired key length in bytes\r\n        h-->str: hash function (name)\r\n        \r\n        Returns-->bytes:\r\n    \r\n    pbkdf2_hmac(h, i, s, r, kl=None)\r\n        Should be identical to original fastpbkdf2.pbkdf2_hmac\r\n        h-->str: hash function (name)\r\n        i-->bytes: input data (password etc)\r\n        s-->bytes: salt\r\n        r-->int: rounds\r\n        kl-->int: desired key length in bytes\r\n        \r\n        Returns-->bytes:\r\n\r\n### DATA\r\n    algorithm = {'sha1': None, 'sha256': None, 'sha512': None}\r\n\r\n\r\n## multikdf.bcrypt\r\n\r\n### FUNCTIONS\r\n    bcrypt_kdf(i, s, r=10, kl=64)\r\n        i-->bytes: input data (password etc)\r\n        s-->bytes: salt (os.urandom)\r\n        r-->int: rounds\r\n        kl-->int: desired key length in bytes\r\n        Returns-->bytes:\r\n        \r\n        (rounds * PerSec) = Machine-specific constant\r\n    \r\n    kdf(password, salt, desired_key_bytes, rounds)\r\n        Should be identical to original bcrypt.kdf\r\n        password-->bytes: input data (password etc)\r\n        salt-->bytes: salt\r\n        desired_key_bytes-->int: desired key length in bytes\r\n        rounds-->int: rounds\r\n        \r\n        Returns-->bytes:\r\n\r\n## multikdf.scrypt\r\n\r\n### FUNCTIONS\r\n    hash(i, s, N=16384, r=8, p=1, buflen=64)\r\n        Should be identical to scrypt.hash\r\n        i-->bytes: input data (password etc)\r\n        s-->bytes: salt\r\n        N-->int: General work factor. Should be a power of 2\r\n                 if N < 2, it is set to 2. Defaults to 16384\r\n        r-->int: Memory cost - defaults to 8\r\n        p-->int: Compuation (parallelization) cost - defaults to 1\r\n        buflen-->int: Desired key length in bytes\r\n        Returns-->bytes:\r\n    \r\n    scrypt_kdf(i, s, r=8, p=1, n=14, kl=64)\r\n        i-->bytes: input data (password etc)\r\n        s-->bytes: salt (os.urandom)\r\n        r-->int: Memory cost - defaults to 8\r\n        p-->int: Compuation (parallelization) cost - defaults to 1\r\n        n-->int: General work factor. passed to scrypt as 2^n\r\n                 if n < 1, it is set to 1. Defaults to 14 (scrypt n=16384)\r\n        Returns-->bytes:\r\n        \r\n        (r * p) should be < 2^30\r\n        see pydoc scrypt.hash\r\n        \r\n        (2^n) * r * p * PerSec = Machine-specific constant\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}